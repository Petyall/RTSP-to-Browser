![Go](https://img.shields.io/badge/go-1.20%2B-blue)
![License](https://img.shields.io/github/license/Petyall/RTSP-to-Browser)
![Framework](https://img.shields.io/badge/Gin-1.10.0-green)

# RTSP-to-Browser: Потоковая передача RTSP-видео в браузер через HLS

Современное и эффективное решение для трансляции RTSP-потоков с IP-камер в браузер с использованием HLS (HTTP Live Streaming). Проект построен на Go с использованием Gin для HTTP-сервера, GORM для работы с базой данных и FFmpeg для обработки видеопотоков. Приложение поддерживает автоматическое управление папками, миграции базы данных и graceful shutdown.

## Основные особенности и преимущества

### 1. **Потоковая передача RTSP**
- **HLS-вывод**. Видеопотоки преобразуются в HLS-сегменты с использованием FFmpeg, обеспечивая совместимость с современными браузерами.
- **Автоматическое определение параметров**. Используется `ffprobe` для получения информации о кодеке, битрейте, разрешении и частоте кадров потока.
- **Аппаратное ускорение**. Поддержка GPU (NVIDIA/AMD) для декодирования и кодирования видео (H.264/H.265) с автоматическим определением оборудования.

### 2. **Интеграция с базой данных**
- **GORM ORM**. Асинхронная и типобезопасная работа с базой данных PostgreSQL через GORM.
- **Миграции базы данных**. Использование `golang-migrate` для автоматического применения миграций при запуске приложения.
- **Модель камер**. Хранение информации о камерах (ID, имя, RTSP-URL) с поддержкой CRUD-операций через GORM.

### 3. **Управление FFmpeg-процессами**
- **Многопоточная обработка**. Каждый RTSP-поток обрабатывается в отдельной горутине с возможностью перезапуска при сбоях.
- **Graceful shutdown**. Корректная остановка всех FFmpeg-процессов и HTTP-сервера по сигналам SIGINT/SIGTERM.
- **Мониторинг ошибок**. Логирование stderr FFmpeg для отладки и диагностики проблем с потоками.

### 4. **Веб-интерфейс**
- **Gin Framework**. Легковесный HTTP-сервер для обслуживания HLS-сегментов и API.
- **Шаблоны HTML**. Использование Go-шаблонов (`html/template`) для рендеринга веб-интерфейса.
- **API для камер**. Эндпоинт `/api/cameras` возвращает список доступных камер с их ID, именами и URL для HLS-потоков.

### 5. **Управление хранилищем**
- **Динамическое создание папок**. Автоматическое создание папок для HLS-сегментов для каждой камеры.
- **Очистка хранилища**. Удаление старых HLS-сегментов при запуске приложения для предотвращения накопления данных.

### 6. **Удобство для разработчиков**
- **Модульная структура**. Код организован по пакетам (`config`, `database`, `ffmpeg`, `server`, `storage`) для удобства поддержки и расширения.
- **Конфигурация через .env**. Настройки базы данных задаются через файл `.env` с использованием `godotenv`.
- **Логирование**. Подробные логи для диагностики работы базы данных, FFmpeg и HTTP-сервера.
- **Масштабируемость**. Легкое добавление новых камер через базу данных и автоматическое управление потоками.

## Структура проекта

```plaintext
├── config/
│   ├── config.go              # Загрузка переменных окружения из .env
├── database/
│   ├── connection.go          # Подключение к PostgreSQL и миграции
│   ├── migrations/            # Файлы миграций базы данных
│   ├── models.go              # Модели GORM для камер
│   ├── queries.go             # Запросы к базе данных
├── ffmpeg/
│   ├── executor.go            # Управление FFmpeg-процессами и обработка потоков
├── server/
│   ├── server.go              # Настройка HTTP-сервера и маршрутов
├── static/
│   ├── css/                   # Стили для веб-интерфейса
│   ├── hls_segments/          # Папка для HLS-сегментов
│   ├── js/                    # Скрипты для веб-интерфейса
├── storage/
│   ├── storage.go             # Управление папками для HLS-сегментов
├── templates/
│   ├── index.html             # Шаблон веб-интерфейса
├── .env-example               # Пример файла .env
├── go.mod                     # Зависимости Go-модуля
├── go.sum                     # Контрольные суммы зависимостей
├── main.go                    # Точка входа приложения
```

## Установка

1. **Клонирование репозитория**.
   ```bash
   git clone https://github.com/Petyall/RTSP-to-Browser.git
   cd RTSP-to-Browser
   ```

2. **Установка зависимостей**.
   ```bash
   go mod tidy
   ```

3. **Настройка переменных окружения**.
   Создайте файл `.env` в корне проекта на основе `.env-example`. Пример:
   ```env
   DB_HOST=localhost
   DB_PORT=5432
   DB_USER=your_user
   DB_PASS=your_password
   DB_NAME=your_database
   DB_SSLMODE=disable
   ```

4. **Установка FFmpeg**.
   Убедитесь, что FFmpeg и ffprobe установлены на вашей системе:
   - **Ubuntu/Debian**:
     ```bash
     sudo apt update
     sudo apt install ffmpeg
     ```
   - **Windows**: Скачайте FFmpeg с [официального сайта](https://ffmpeg.org/download.html) и добавьте в PATH.
   - **macOS**:
     ```bash
     brew install ffmpeg
     ```

5. **Применение миграций базы данных**.
   Миграции применяются автоматически при запуске приложения. Убедитесь, что PostgreSQL запущен и база данных настроена.

6. **Запуск приложения**.
   ```bash
   go run main.go
   ```

7. **Проверка работоспособности**.
   Откройте браузер и перейдите по адресу:
   ```bash
   http://localhost:8080
   ```

## Эндпоинты API

Ниже приведены основные эндпоинты API с примерами запросов и ответов. Все эндпоинты возвращают JSON-ответы.

### Камеры

#### GET /api/cameras
Возвращает список всех доступных камер.

- **Успешный ответ (200)**:
  ```json
  [
    {
      "id": 1,
      "name": "Camera 1",
      "url": "/hls/camera_1/stream.m3u8"
    },
    {
      "id": 2,
      "name": "Camera 2",
      "url": "/hls/camera_2/stream.m3u8"
    }
  ]
  ```
- **Ошибка (500, ошибка сервера)**:
  ```json
  {
    "error": "Ошибка сервера"
  }
  ```

#### GET /hls/camera_{id}/stream.m3u8
Возвращает HLS-плейлист для указанной камеры.

- **Успешный ответ (200)**: Плейлист в формате `.m3u8`.
- **Ошибка (404, камера не найдена)**: Если папка или плейлист отсутствуют.

## Требования

- Go 1.20+
- PostgreSQL
- FFmpeg и ffprobe
- Зависимости из `go.mod`

## Миграции базы данных

Проект использует `golang-migrate` для управления схемой базы данных. Миграции применяются автоматически при запуске приложения. Для создания новой миграции:
```bash
migrate create -ext sql -dir database/migrations -seq "описание_миграции"
```
Для ручного применения миграций:
```bash
migrate -path database/migrations -database "postgresql://user:password@localhost:5432/dbname?sslmode=disable" up
```